// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-falcor-json-graph/9db4cc817e676b1317d4b19f3ed9753be10eff91/src/index.d.ts
declare module '~falcor-router~falcor~falcor-json-graph/src/index' {
export interface Atom <T> {
  $type: 'atom';
  value: T;
}

export interface Error <T> {
  $type: 'error';
  value: T;
}

export interface Reference {
  $type: 'ref';
  value: Path;
}

export type Key = string | number | boolean;
export type Path = Array<Key>;

export type KeySet = Key | Range | Array<Key | Range>;
export type PathSet = Array<KeySet>;

export interface InvalidPath {
  path: PathSet;
  invalidated: boolean;
}

export interface PathValue <T> {
  path: string | PathSet;
  value: T;
}

export interface JSONEnvelope <T> {
  json: T;
}

export interface JSONGraph {
  [key: string]: string | number | boolean | Atom<any> | Reference | JSONGraph;
}

export interface JSONGraphEnvelope {
  jsonGraph: JSONGraph;
  paths?: Array<PathSet>;
  invalidate?: Array<PathSet>;
}

export interface Props {
  $expires?: number;
}

export type Range = { from: number; to: number } | { from?: number; length: number };

export function ref <P extends Props> (path: string | PathSet, props?: P): Reference & P;
export function atom <T, P extends Props>  (value: T, props?: P): Atom<T> & P;
export function undefined (): Atom<void>;
export function error <T, P> (errorValue: T, props?: P): Error<T> & P;
export function pathValue <T> (path: string | PathSet, value: T): PathValue<T>;
export function pathInvalidation (path: string | PathSet): InvalidPath;
}
declare module '~falcor-router~falcor~falcor-json-graph' {
export * from '~falcor-router~falcor~falcor-json-graph/src/index';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-falcor/4475f12c6e68d76b732fc35129794a3649accebb/lib/index.d.ts
declare module '~falcor-router~falcor/lib/index' {
import { Path, PathSet, PathValue, JSONEnvelope, JSONGraph, JSONGraphEnvelope } from '~falcor-router~falcor~falcor-json-graph'

/**
 * A DataSource is an interface which can be implemented to expose JSON Graph information to a Model. Every DataSource is associated with a single JSON Graph object. Models execute JSON Graph operations (get, set, and call) to retrieve values from the DataSourceâ€™s JSON Graph object. DataSources may retrieve JSON Graph information from anywhere, including device memory, a remote machine, or even a lazily-run computation.
 */
export abstract class DataSource {
  /**
   * The get method retrieves values from the DataSource's associated JSONGraph object.
   */
  get (pathSets: Array<PathSet>): Observable<JSONGraphEnvelope>;


  /**
   * The set method accepts values to set in the DataSource's associated JSONGraph object.
   */
  set (jsonGraphEnvelope: JSONGraphEnvelope): Observable<JSONGraphEnvelope>;


  /**
   * Invokes a function in the DataSource's JSONGraph object.
   */
  call (functionPath: Path, args?: Array<any>, refSuffixes?: Array<PathSet>, thisPaths?: Array<PathSet>): Observable<JSONGraphEnvelope>;
}

export class HttpDataSource extends DataSource {}

export interface ModelOptions {
  source?: DataSource;
  cache?: JSONGraph;
  maxSize?: number;
  collectRatio?: number;
  errorSelector?: ModelErrorSelector;
  onChange?: ModelOnChange;
  comparator?: ModelComparator;
}

/**
 * This callback is invoked when the Model's cache is changed.
 */
export interface ModelOnChange {
  (): void;
}

/**
 * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.
 */
export interface ModelErrorSelector {
  (jsonGraphError: any): any;
}

/**
 * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.
 */
export interface ModelComparator {
  (existingValue: any, newValue: any): boolean;
}

/**
 * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.
 */
export class Model {
  constructor(options?: ModelOptions);

  /**
   * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.
   */
  get (...path: Array<string | PathSet>): ModelResponse<JSONEnvelope<any>>;
  get <T> (...path: Array<string | PathSet>): ModelResponse<JSONEnvelope<T>>;

  /**
   * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.
   */
  set (...args: Array<PathValue<any>>): ModelResponse<JSONEnvelope<any>>;
  set <T> (...args: Array<PathValue<any>>): ModelResponse<JSONEnvelope<T>>;
  set (jsonGraph: JSONGraph): ModelResponse<JSONEnvelope<any>>;
  set <T> (jsonGraph: JSONGraph): ModelResponse<JSONEnvelope<T>>;

  /**
   * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.
   */
  preload (...path: Array<PathSet>): void;

  /**
   * Invokes a function in the JSON Graph.
   */
  call (functionPath: string | Path, args?: Array<any>, refPaths?: PathSet, thisPaths?: Array<PathSet>): ModelResponse<JSONEnvelope<any>>;
  call <T> (functionPath: string | Path, args?: Array<any>, refPaths?: PathSet, thisPaths?: Array<PathSet>): ModelResponse<JSONEnvelope<T>>;

  /**
   * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.
   */
  invalidate (...path: Array<PathSet>): void;

  /**
   * Returns a new {@link Model} bound to a location within the {@link JSONGraph}. The bound location is never a {@link Reference}: any {@link Reference}s encountered while resolving the bound {@link Path} are always replaced with the {@link Reference}s target value. For subsequent operations on the {@link Model}, all paths will be evaluated relative to the bound path. Deref allows you to:
   * - Expose only a fragment of the {@link JSONGraph} to components, rather than the entire graph
   * - Hide the location of a {@link JSONGraph} fragment from components
   * - Optimize for executing multiple operations and path looksup at/below the same location in the {@link JSONGraph}
   */
  deref (responseObject: any): this;

  /**
   * Get data for a single {@link Path}.
   */
  getValue (path: string | Path): ModelResponse<any>;
  getValue <T> (path: string | Path): ModelResponse<T>;

  /**
   * Set value for a single {@link Path}.
   */
  setValue (path: string | Path, value: any): ModelResponse<any>;
  setValue <T> (path: string | Path, value: any): ModelResponse<T>;

  /**
   * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.
   */
  setCache (jsonGraph: JSONGraph): void;

  /**
   * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.
   */
  getCache (...path: Array<PathSet>): JSONGraph;

  /**
   * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.
   */
  getVersion (path?: Path): number;

  /**
   * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.
   */
  batch (schedulerOrDelay?: number | Scheduler): this;

  /**
   * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.
   */
  unbatch (): this;

  /**
   * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.
   */
  treatErrorsAsValues (): this;

  /**
   * Adapts a Model to the {@link DataSource} interface.
   */
  asDataSource (): DataSource;

  /**
   * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.
   */
  boxValues (): Model;

  /**
   * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.
   */
  unboxValues (): Model;

  /**
   * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.
   */
  withoutDataSource (): Model;

  /**
   * Returns the {@link Path} to the object within the JSON Graph that this Model references.
   */
  getPath (): Path;
}

export class ModelResponse <T> extends Observable <T> implements Thenable <T> {
  constructor (observable: Observable<T>);
  progressively (): ModelResponse<JSONEnvelope<T>>;
  forEach (onNext: (value: T) => void, onError?: (error: Error) => void, onCompleted?: () => void): Subscription;
  then <U> (onFulfilled?: (value: T) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
}

interface Thenable <R> {
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
}

export class Observable <T> {
    /**
     * The forEach method is a synonym for {@link Observable.prototype.subscribe} and triggers the execution of the Observable, causing the values within to be pushed to a callback. An Observable is like a pipe of water that is closed. When forEach is called, we open the valve and the values within are pushed at us.  These values can be received using either callbacks or an {@link Observer} object.
     */
    forEach (onNext?: (value: T) => any, onError?: (error: Error) => any, onCompleted?: () => any): Subscription;

    /**
     * The subscribe method is a synonym for {@link Observable.prototype.forEach} and triggers the execution of the Observable, causing the values within to be pushed to a callback. An Observable is like a pipe of water that is closed. When forEach is called, we open the valve and the values within are pushed at us.  These values can be received using either callbacks or an {@link Observer} object.
     */
    subscribe (onNext?: (value: T) => any, onError?: (error: Error) => any, onCompleted?: () => any): Subscription;
}

export class Subscription {
  /**
   * When this method is called on the Subscription, the Observable that created the Subscription will stop sending values to the callbacks passed when the Subscription was created.
   */
  dispose (): void;
}

export interface Scheduler {
  catch (handler: (exception: any) => boolean): Scheduler;
  catchException (handler: (exception: any) => boolean): Scheduler;
}
}
declare module '~falcor-router~falcor' {
export * from '~falcor-router~falcor/lib/index';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-falcor-json-graph/9db4cc817e676b1317d4b19f3ed9753be10eff91/src/index.d.ts
declare module '~falcor-router~falcor-json-graph/src/index' {
export interface Atom <T> {
  $type: 'atom';
  value: T;
}

export interface Error <T> {
  $type: 'error';
  value: T;
}

export interface Reference {
  $type: 'ref';
  value: Path;
}

export type Key = string | number | boolean;
export type Path = Array<Key>;

export type KeySet = Key | Range | Array<Key | Range>;
export type PathSet = Array<KeySet>;

export interface InvalidPath {
  path: PathSet;
  invalidated: boolean;
}

export interface PathValue <T> {
  path: string | PathSet;
  value: T;
}

export interface JSONEnvelope <T> {
  json: T;
}

export interface JSONGraph {
  [key: string]: string | number | boolean | Atom<any> | Reference | JSONGraph;
}

export interface JSONGraphEnvelope {
  jsonGraph: JSONGraph;
  paths?: Array<PathSet>;
  invalidate?: Array<PathSet>;
}

export interface Props {
  $expires?: number;
}

export type Range = { from: number; to: number } | { from?: number; length: number };

export function ref <P extends Props> (path: string | PathSet, props?: P): Reference & P;
export function atom <T, P extends Props>  (value: T, props?: P): Atom<T> & P;
export function undefined (): Atom<void>;
export function error <T, P> (errorValue: T, props?: P): Error<T> & P;
export function pathValue <T> (path: string | PathSet, value: T): PathValue<T>;
export function pathInvalidation (path: string | PathSet): InvalidPath;
}
declare module '~falcor-router~falcor-json-graph' {
export * from '~falcor-router~falcor-json-graph/src/index';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-es6-promise/fb04188767acfec1defd054fc8024fafa5cd4de7/dist/es6-promise.d.ts
declare module '~falcor-router~es6-promise/dist/es6-promise' {
export interface Thenable <R> {
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Thenable<U>;
}

export class Promise <R> implements Thenable <R> {
  /**
   * If you call resolve in the body of the callback passed to the constructor,
   * your promise is fulfilled with result object passed to resolve.
   * If you call reject your promise is rejected with the object passed to resolve.
   * For consistency and debugging (eg stack traces), obj should be an instanceof Error.
   * Any errors thrown in the constructor callback will be implicitly passed to reject().
   */
  constructor (callback: (resolve : (value?: R | Thenable<R>) => void, reject: (error?: any) => void) => void);

  /**
   * onFulfilled is called when/if "promise" resolves. onRejected is called when/if "promise" rejects.
   * Both are optional, if either/both are omitted the next onFulfilled/onRejected in the chain is called.
   * Both callbacks have a single parameter , the fulfillment value or rejection reason.
   * "then" returns a new promise equivalent to the value you return from onFulfilled/onRejected after being passed through Promise.resolve.
   * If an error is thrown in the callback, the returned promise rejects with that error.
   *
   * @param onFulfilled called when/if "promise" resolves
   * @param onRejected called when/if "promise" rejects
   */
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Promise<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Promise<U>;

  /**
   * Sugar for promise.then(undefined, onRejected)
   *
   * @param onRejected called when/if "promise" rejects
   */
  catch <U> (onRejected?: (error: any) => U | Thenable<U>): Promise<U>;

  /**
   * Make a new promise from the thenable.
   * A thenable is promise-like in as far as it has a "then" method.
   */
  static resolve (): Promise<void>;
  static resolve <R> (value: R | Thenable<R>): Promise<R>;

  /**
   * Make a promise that rejects to obj. For consistency and debugging (eg stack traces), obj should be an instanceof Error
   */
  static reject <R> (error: any): Promise<R>;

  /**
   * Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
   * the array passed to all can be a mixture of promise-like objects and other objects.
   * The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
   */
  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>, T10 | Thenable<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
  static all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
  static all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;
  static all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;
  static all<T1, T2, T3, T4, T5, T6>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;
  static all<T1, T2, T3, T4, T5>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>]): Promise<[T1, T2, T3, T4, T5]>;
  static all<T1, T2, T3, T4>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>]): Promise<[T1, T2, T3, T4]>;
  static all<T1, T2, T3>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>]): Promise<[T1, T2, T3]>;
  static all<T1, T2>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>]): Promise<[T1, T2]>;
  static all<T1>(values: [T1 | Thenable<T1>]): Promise<[T1]>;
  static all<TAll>(values: Array<TAll | Thenable<TAll>>): Promise<TAll[]>;

  /**
   * Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
   */
  static race <R> (promises: (R | Thenable<R>)[]): Promise<R>;
}

/**
 * The polyfill method will patch the global environment (in this case to the Promise name) when called.
 */
export function polyfill (): void;
}
declare module '~falcor-router~es6-promise' {
export * from '~falcor-router~es6-promise/dist/es6-promise';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-falcor-router/1c32df6c9f3bfc47237f1969b119f4e1fe2e2e9a/src/Router.d.ts
declare module '~falcor-router/src/Router' {
import { DataSource } from '~falcor-router~falcor'
import { PathSet, JSONGraph, PathValue, JSONEnvelope } from '~falcor-router~falcor-json-graph'
import { Thenable } from '~falcor-router~es6-promise'

class Router extends DataSource {
  constructor (routes: Array<Router.Definition>, options?: Router.Options);

  /**
   * When a route misses on a call, get, or set the unhandledDataSource will
   * have a chance to fulfill that request.
   */
  routeUnhandledPathsTo (dataSource: DataSource): void;

  static createClass (routes?: Array<Router.Definition>): typeof Router.CreatedRouter;
}

namespace Router {
  export interface Options {
    debug?: boolean;
    maxPaths?: number;
    maxRefFollow?: number;
  }

  export class CreatedRouter extends Router {
    constructor(options?: Options);
  }

  export interface Route {
    route: string;
  }

  export interface CallRoute extends Route {
    call (callPath: PathSet, args: Array<any>): Result<any> | Thenable<Result<any>>;
  }

  export interface GetRoute extends Route {
    get (pathset: PathSet): Result<any> | Thenable<Result<any>>;
  }

  export interface SetRoute extends Route {
    set (jsonGraph: JSONGraph): Result<any> | Thenable<Result<any>>;
  }

  export type Definition = GetRoute | SetRoute | CallRoute;

  export type Result <T> = PathValue<T> | Array<PathValue<T>> | JSONEnvelope<T>;

  export var ranges: string;
  export var integers: string;
  export var keys: string;

  export class JSONGraphError extends Error {
    constructor (typeValue: any);
    typeValue: any;
  }
}

export = Router;
}
declare module 'falcor-router/src/Router' {
import main = require('~falcor-router/src/Router');
export = main;
}
declare module 'falcor-router' {
import main = require('~falcor-router/src/Router');
export = main;
}
